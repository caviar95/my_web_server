# Timer

## 1 原因
如何在现有的Web服务器代码中加入定时器机制。

考虑用户的可能需求：使用定时器来处理超时连接，比如长时间不活动的客户端，或者执行定期任务，比如日志轮转。

首先，之前的代码使用了epoll和线程池，所以定时器需要与现有的epoll事件循环集成。考虑使用Linux的timerfd，因为它可以很好地与epoll结合，通过文件描述符来通知定时事件。这种方法不需要额外的线程，适合现有的架构。

设计定时器的结构。为每个客户端连接设置超时，因此需要记录每个连接的最后活动时间。当定时器触发时，遍历所有连接，关闭那些超过设定时间的。同时，服务器需要处理定时器事件和普通I/O事件，这需要修改epoll的事件处理逻辑。

另外，希望定时器能够定期触发，比如每5秒检查一次超时连接。使用timerfd_create创建定时器，并设置间隔时间。在定时器触发时，读取timerfd的事件，然后执行超时检查。

还要注意线程安全的问题，因为定时器可能在主线程触发，而连接列表可能在多个线程中被修改。需要使用互斥锁来保护共享资源，比如连接列表和最后活动时间。

修改现有的Server类，添加定时器相关的成员变量和方法。包括初始化定时器，将timerfd添加到epoll监听，处理定时器事件，更新连接的活动时间，以及超时处理逻辑。

可能遇到的问题包括如何高效地管理大量连接的定时检查。可以使用哈希表或优先队列来跟踪最近的活动时间，但为了简单起见，可能先用一个列表或映射结构，并在每次定时器触发时遍历所有连接，检查是否超时。虽然这在连接数多时可能效率不高，但对于示例代码来说足够。

最后，需要测试定时器功能是否正常工作，比如模拟客户端不发送数据，看服务器是否能自动关闭连接。同时确保添加定时器后不影响原有的HTTP请求处理流程。

总结步骤：添加Timer类，修改Server类以包含定时器，初始化定时器并加入epoll监听，处理定时器事件，更新连接活动时间，实现超时检查。同时处理必要的同步机制，确保线程安全。

## 2 目标

1 检测长时间未活动的客户端连接，自动关闭释放资源。
2 支持周期性任务（如日志轮转）。


## 3 设计选择

1 使用 timerfd + epoll 实现高精度定时器。
2 用时间轮管理客户端连接超时。

## 4 关键逻辑

### 4.1 定时器初始化

1 创建 timerfd 并设置周期性触发（例如每5秒一次）。
2 将 timerfd 加入 epoll 监听列表。

### 4.2 超时检测

1 每次定时器触发时，遍历所有连接的最近活动时间。
2 关闭超过60秒未活动的连接。

### 4.3 连接活动记录

1 每次收到客户端数据时更新其最后活动时间。
2 客户端关闭连接时从记录中移除。

## 5 扩展方向

### 5.1 动态超时时间
可根据不同请求类型设置不同的超时阈值。

### 5.2 高效时间轮
使用时间轮算法替代 unordered_map 提升超时检测效率。

### 5.3 心跳机制
客户端定期发送心跳包，服务器重置超时计时器。

## 6 成果

通过以上实现，服务器能够自动清理僵尸连接，提升资源利用率。